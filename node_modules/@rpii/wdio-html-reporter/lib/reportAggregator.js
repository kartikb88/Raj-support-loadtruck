"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const htmlGenerator_1 = __importDefault(require("./htmlGenerator"));
const types_1 = require("./types");
const dayjs_1 = __importDefault(require("dayjs"));
const utc_1 = __importDefault(require("dayjs/plugin/utc"));
dayjs_1.default.extend(utc_1.default);
const isSameOrBefore_1 = __importDefault(require("dayjs/plugin/isSameOrBefore"));
dayjs_1.default.extend(isSameOrBefore_1.default);
const open = require('open');
const copyfiles = require("copyfiles");
const fs = require('fs-extra');
const path = require('path');
const log4js = require('@log4js-node/log4js-api');
function walk(dir, extensions, filelist = []) {
    const files = fs.readdirSync(dir);
    files.forEach(function (file) {
        const filepath = path.join(dir, file);
        const stat = fs.statSync(filepath);
        if (stat.isDirectory()) {
            filelist = walk(filepath, extensions, filelist);
        }
        else {
            extensions.forEach(function (extension) {
                if (file.indexOf(extension) == file.length - extension.length) {
                    filelist.push(filepath);
                }
            });
        }
    });
    return filelist;
}
class ReportAggregator {
    constructor(opts) {
        this.reportFile = "";
        opts = Object.assign({}, {
            outputDir: 'reports/html-reports/',
            filename: 'master-report.html',
            reportTitle: 'Test Master Report',
            showInBrowser: false,
            templateFilename: path.resolve(__dirname, '../templates/wdio-html-reporter-template.hbs'),
            browserName: "not specified",
            collapseTests: false,
            LOG: null,
            removeOutput: true
        }, opts);
        this.options = opts;
        if (!this.options.LOG) {
            this.options.LOG = log4js.getLogger(this.options.debug ? 'debug' : 'default');
        }
        this.reports = [];
    }
    clean() {
        fs.emptyDirSync(this.options.outputDir);
    }
    readJsonFiles() {
        return walk(this.options.outputDir, [".json"]);
    }
    createReport() {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.LOG.info("Report Aggregation started");
            let metrics = new types_1.Metrics();
            let suites = [];
            let specs = [];
            let files = this.readJsonFiles();
            for (let i = 0; i < files.length; i++) {
                try {
                    let filename = files[i];
                    let report = JSON.parse(fs.readFileSync(filename));
                    if (!report.info || !report.info.specs) {
                        this.options.LOG.error("report structure in question, no info or info.specs ", JSON.stringify(report));
                        this.options.LOG.debug("report content: ", JSON.stringify(report));
                    }
                    report.info.specs.forEach((spec) => {
                        specs.push(spec);
                    });
                    this.reports.push(report);
                    metrics.passed += report.metrics.passed;
                    metrics.failed += report.metrics.failed;
                    metrics.skipped += report.metrics.skipped;
                    metrics.start = dayjs_1.default().utc().format("YYYY-MM-DDTHH:mm:ss.SSS[Z]");
                    metrics.end = dayjs_1.default("2021-01-01").utc().format();
                    for (let k = 0; k < report.suites.length; k++) {
                        let suiteInfo = report.suites[k];
                        let start = dayjs_1.default.utc(suiteInfo.suite.start);
                        if (start.isSameOrBefore(metrics.start)) {
                            metrics.start = start.utc().format("YYYY-MM-DDTHH:mm:ss.SSS[Z]");
                        }
                        let end = dayjs_1.default.utc(suiteInfo.suite.end);
                        if (end.isAfter(dayjs_1.default.utc(metrics.end))) {
                            metrics.end = end.utc().format("YYYY-MM-DDTHH:mm:ss.SSS[Z]");
                        }
                        suites.push(suiteInfo);
                    }
                }
                catch (ex) {
                    console.error(ex);
                }
            }
            if (!this.reports || !this.reports.length) {
                // the test failed hard at the beginning.  Create a dummy structure to get through html generation
                let report = {
                    "info": {
                        "cid": "The execution of the test suite has failed before report generation was started.  Please look at the logs to determine the error, this is likely an issue with your configuration files.",
                        "config": {
                            "hostname": "localhost"
                        },
                        "specs": [],
                        "suites": [
                            {
                                "uid": "Test Start Failure",
                                "title": "Test Start Failure",
                                "type": "suite",
                                "tests": [],
                            }
                        ]
                    }
                };
                this.reports = [];
                this.reports.push(report);
            }
            metrics.duration = dayjs_1.default.duration(dayjs_1.default(metrics.end).utc().diff(dayjs_1.default(metrics.start).utc())).as('milliseconds');
            this.options.LOG.info("Aggregated " + specs.length + " specs, " + suites.length + " suites, " + this.reports.length + " reports, ");
            this.reportFile = path.join(process.cwd(), this.options.outputDir, this.options.filename);
            if (this.options.removeOutput) {
                for (let i = 0; i < suites.length; i++) {
                    let suite = suites[i].suite;
                    for (let j = 0; j < suite.tests.length; j++) {
                        let test = suite.tests[j];
                        test.output = [];
                    }
                    let tests = suite.tests;
                    for (let k = 0; k < tests.length; k++) {
                        let test = tests[k];
                        test.output = [];
                    }
                }
            }
            let reportData = new types_1.ReportData(this.options.reportTitle, this.reports[0].info, suites, metrics, this.reportFile, this.options.browserName);
            htmlGenerator_1.default.htmlOutput(this.options, reportData);
            this.options.LOG.info("Report Aggregation completed");
            let jsFiles = path.join(__dirname, '../css/*.*');
            let reportDir = path.join(process.cwd(), this.options.outputDir);
            copyfiles([jsFiles, reportDir], true, () => {
                this.options.LOG.info('copyfiles complete : ' + jsFiles + " to " + reportDir);
                try {
                    if (this.options.showInBrowser) {
                        let childProcess = open(reportData.reportFile);
                        childProcess.then(() => {
                            this.options.LOG.info('browser launched');
                        }, (error) => {
                            this.options.LOG.error('showInBrowser error spawning :' + reportData.reportFile + " " + error.toString());
                        });
                    }
                }
                catch (ex) {
                    this.options.LOG.error('Error opening browser:' + ex);
                }
            });
        });
    }
}
exports.default = ReportAggregator;
