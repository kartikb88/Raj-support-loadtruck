"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const reporter_1 = __importDefault(require("@wdio/reporter"));
const htmlGenerator_1 = __importDefault(require("./htmlGenerator"));
const types_1 = require("./types");
const dayjs_1 = __importDefault(require("dayjs"));
const wdio_report_events_1 = __importDefault(require("@rpii/wdio-report-events"));
const fs = require('fs-extra');
const path = require('path');
const log4js = require('@log4js-node/log4js-api');
let proxy = new wdio_report_events_1.default();
class HtmlReporter extends reporter_1.default {
    constructor(options) {
        super(Object.assign({
            stdout: true,
            logFile: './logs/reporter.log',
        }, options));
        this._suiteIndents = {};
        this._suiteUids = new Set();
        this._orderedSuites = [];
        let opts = {
            stdout: true,
            outputDir: 'reports/html-reports/',
            filename: 'report.html',
            templateFilename: path.resolve(__dirname, '../templates/wdio-html-reporter-template.hbs'),
            reportTitle: 'Test Report Title',
            useOnAfterCommandForScreenshot: true
        };
        this.options = Object.assign(opts, options);
        if (!this.options.LOG) {
            this.options.LOG = log4js.getLogger(this.options.debug ? 'debug' : 'default');
            ;
        }
        const dir = this.options.outputDir + 'screenshots';
        fs.ensureDirSync(dir);
        this._indents = 0;
        this._suiteIndents = {};
        this._suiteStats = [];
        this.metrics = new types_1.Metrics();
        this.openInProgress = false;
        this.defaultTestIndent = '   ';
        this._currentSuiteUid = "suite uid";
        this._currentTestUid = "test uid";
        this._currentCid = "cid";
        proxy.connectMessageEvent(this.saveMessage.bind(this));
        proxy.connectScreenshotEvent(this.saveScreenshot.bind(this));
    }
    get isSynchronised() {
        return !this.openInProgress;
    }
    onRunnerStart(runner) {
        this.options.LOG.info("onRunnerStart:");
        this.options.LOG.debug(JSON.stringify(runner));
        //todo look at fix, not async safe. but one cid per report file
        this._currentCid = runner.cid;
        this.metrics.passed = 0;
        this.metrics.skipped = 0;
        this.metrics.failed = 0;
        this.metrics.start = dayjs_1.default().utc().format("YYYY-MM-DDTHH:mm:ss.SSS[Z]");
    }
    onSuiteStart(suite) {
        this._suiteUids.add(suite.uid);
        if (suite.type === 'feature') {
            this._indents = 0;
            this._suiteIndents[suite.uid] = this._indents;
        }
        else {
            this._suiteIndents[suite.uid] = ++this._indents;
        }
        this._currentSuiteUid = suite.uid;
        let thisSuite = new types_1.SuiteInfo('suite', suite);
        this._suiteStats.push(thisSuite);
        this.options.LOG.info("onSuiteStart:");
        this.options.LOG.debug(JSON.stringify(thisSuite));
    }
    onTestStart(theTest) {
        this.options.LOG.info("onTestStart:");
        this.options.LOG.debug(JSON.stringify(theTest));
        this._currentTestUid = theTest.uid;
        let test = new types_1.TestInfo(theTest);
        this.pushTest(test);
        test.events = [];
        test.errorIndex = 0;
    }
    onTestPass(test) {
        this.options.LOG.info("onTestPass:");
        this.options.LOG.debug(JSON.stringify(test));
        this.metrics.passed++;
    }
    onTestSkip(test) {
        this.options.LOG.info("onTestSkip:");
        this.options.LOG.debug(JSON.stringify(test));
        this.metrics.skipped++;
    }
    onTestFail(theTest) {
        this.options.LOG.info("onTestFail:");
        this.options.LOG.debug(JSON.stringify(theTest));
        let test = this.getTest(theTest.uid);
        if (test) {
            this.moveErrorsToEvents(test);
        }
        this.metrics.failed++;
    }
    onTestEnd(theTest) {
        this.options.LOG.info("onTestEnd:");
        this.options.LOG.debug(JSON.stringify(theTest));
        let test = this.getTest(theTest.uid);
        if (test) {
            this.moveErrorsToEvents(test);
        }
    }
    onHookEnd(hook) {
        if (hook.error) {
            this.metrics.failed++;
        }
    }
    onSuiteEnd(suite) {
        this.options.LOG.info("onSuiteEnd:");
        this.options.LOG.debug(JSON.stringify(suite));
        this._indents--;
        // this is to display suite end time and duration in master report.
        for (const suiteInfo of this._suiteStats) {
            if (suiteInfo.suite.uid == suite.uid) {
                suiteInfo.suite.end = suite.end;
                suiteInfo.suite._duration = suite._duration;
                break;
            }
        }
    }
    isScreenshotCommand(command) {
        const isScreenshotEndpoint = /\/session\/[^/]*(\/element\/[^/]*)?\/screenshot/;
        return (
        // WebDriver protocol
        (command.endpoint && isScreenshotEndpoint.test(command.endpoint)) ||
            // DevTools protocol
            command.command === 'takeScreenshot');
    }
    //this is a hack to get around lack of onScreenshot event
    onAfterCommand(command) {
        if (this.options.useOnAfterCommandForScreenshot) {
            if (this.isScreenshotCommand(command) && command.result.value) {
                let timestamp = dayjs_1.default().format('YYYYMMDD-HHmmss.SSS');
                const filepath = path.join(this.options.outputDir, '/screenshots/', encodeURIComponent(this._currentCid), timestamp, this.options.filename + '.png');
                this.options.LOG.info("onAfterCommand: taking screenshot ", filepath);
                fs.outputFileSync(filepath, Buffer.from(command.result.value, 'base64'));
                let test = this.getTest(this._currentTestUid);
                if (test) {
                    test.events.push({ type: 'screenshot', value: filepath });
                }
            }
        }
    }
    onRunnerEnd(runner) {
        this.options.LOG.info("onRunnerEnd: ");
        this.options.LOG.debug(JSON.stringify(runner));
        this.openInProgress = true;
        this.metrics.end = dayjs_1.default().utc().format();
        this.metrics.duration = runner._duration;
        //error handling protection
        if (!this._currentSuiteUid) {
            this._currentSuiteUid = "suite";
        }
        if (!this._currentCid) {
            this._currentCid = "cid";
        }
        let reportFile = path.join(process.cwd(), this.options.outputDir, encodeURIComponent(this._currentSuiteUid), encodeURIComponent(this._currentCid), this.options.filename);
        let reportData = new types_1.ReportData(this.options.reportTitle, runner, this.getOrderedSuites(), this.metrics, reportFile, this.options.browserName);
        htmlGenerator_1.default.htmlOutput(this.options, reportData, () => {
            this.openInProgress = false;
        });
    }
    getSuite(uid) {
        if (uid) {
            for (let i = 0; i < this._suiteStats.length; i++) {
                if (uid === this._suiteStats[i].suite.uid) {
                    return this._suiteStats[i];
                }
            }
        }
        return undefined;
    }
    getTest(uid) {
        let suiteInfo = this.getSuite(this._currentSuiteUid);
        if (suiteInfo) {
            for (let i = 0; i < suiteInfo.tests.length; i++) {
                if (uid === suiteInfo.tests[i].testStats.uid) {
                    return suiteInfo.tests[i];
                }
            }
        }
        return undefined;
    }
    pushTest(test) {
        let suiteInfo = this.getSuite(this._currentSuiteUid);
        if (suiteInfo) {
            suiteInfo.tests.push(test);
        }
    }
    //this is a hack.  we have to move all the things in test.errors before they get blown away
    moveErrorsToEvents(test) {
        if (test.testStats.errors) {
            for (let i = test.errorIndex; i < test.testStats.errors.length; i++) {
                test.events.push(new types_1.InternalReportEvent('Error', test.testStats.errors[i]));
            }
            test.errorIndex = test.testStats.errors.length;
        }
    }
    saveScreenshot(filepath) {
        let test = this.getTest(this._currentTestUid);
        if (test) {
            this.moveErrorsToEvents(test);
            test.events.push(new types_1.InternalReportEvent('screenshot', filepath));
        }
    }
    saveMessage(message) {
        const test = this.getTest(this._currentTestUid);
        if (test) {
            this.moveErrorsToEvents(test);
            test.events.push({ type: 'log', value: message });
        }
    }
    /**
     * Get suites in the order they were called
     * @return {Array} Ordered suites
     */
    getOrderedSuites() {
        if (this._orderedSuites.length) {
            return this._orderedSuites;
        }
        this._orderedSuites = [];
        for (const uid of this._suiteUids) {
            for (const suite of this._suiteStats) {
                if (suite.suite.uid !== uid) {
                    continue;
                }
                this._orderedSuites.push(suite);
            }
        }
        return this._orderedSuites;
    }
    indent(uid) {
        const indents = this._suiteIndents[uid];
        return indents === 0 ? '' : Array(indents).join('    ');
    }
}
exports.default = HtmlReporter;
